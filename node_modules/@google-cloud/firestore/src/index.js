/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @module firestore
 */

'use strict';

var bun = require('bun');
var common = require('@google-cloud/common');
var commonGrpc = require('@google-cloud/common-grpc');
var extend = require('extend');
var is = require('is');
var through = require('through2');
var util = require('util');

var v1beta1 = require('./v1beta1');
var reference = require('./reference')(Firestore);

/**
 * @type firestore.CollectionReference
 * @private
 */
var CollectionReference = reference.CollectionReference;

/**
 * @type firestore.DocumentReference
 * @private
 */
var DocumentReference = reference.DocumentReference;

/**
 * @private
 */
var document = require('./document')(Firestore, DocumentReference);

/**
 * @type firestore.DocumentSnapshot
 * @private
 */
var DocumentSnapshot = document.DocumentSnapshot;

/**
 * @type firestore.GeoPoint
 * @private
 */
var GeoPoint = document.GeoPoint;

/**
 * @type firestore.Path
 * @private
 */
var Path = require('./path');

/**
 * @private
 */
var validate = require('./validate.js')({
  DocumentReference: reference.validateDocumentReference
});

/**
 * @type firestore.WriteBatch
 * @private
 */
var WriteBatch = require('./write-batch')(
    Firestore, DocumentReference).WriteBatch;

/**
 * @type firestore.Transaction
 * @private
 */
var Transaction = require('./transaction')(Firestore);

/**
 * HTTP header for the resource prefix to improve routing and project isolation
 * by the backend.
 * @type string
 * @private
 */
const CLOUD_RESOURCE_HEADER = 'google-cloud-resource-prefix';

/**
 * @class
 *
 * The Firestore client represents a Firestore Database and is the entry point
 * for all Firestore operations.
 *
 * @resource [Firestore Documentation]{@link https://firebase.google.com/docs/firestore/}
 *
 * @public
 * @alias firestore.Firestore
 *
 * @param {object=} options - [Configuration object](#/docs).
 */
function Firestore(options) {
  if (!(this instanceof Firestore)) {
    options = common.util.normalizeArguments(this, options);
    return new Firestore(options);
  }

  options = extend({}, options, {
    libName: 'gccl',
    libVersion: require('../package.json').version
  });

  /**
   * The Firestore GAPIC client.
   * @package
   */
  this.api = {
    Firestore: v1beta1(options).firestoreClient(options)
  };

  if (options && options.projectId) {
    this.referencePath_ = new Path(options.projectId, '(default)', []);
  } else {
    this.referencePath_ = new Path('{{projectId}}', '(default)', []);
  }

  /**
   * The root path to the database.
   * @package
   * @type string
   */
  Object.defineProperty(this, 'formattedName', {
    get: () => {
      return this.referencePath_.formattedName;
    }
  });

  var config = {
    service: 'firestore',
    apiVersion: 'v1beta1',
    // @todo: Pass in proto services via googleprotofiles once v1beta1 protos
    // are publicly available:
    //
    // protoServices: {
    //    Firestore:  googleProtoFiles('firestore', 'v1beta1',
    //                'firestore.proto'),
    // }
    protoServices: {},
    packageJson: require('../package.json')
  };

  commonGrpc.Service.call(this, config, options);
}

util.inherits(Firestore, commonGrpc.Service);

/**
 * Gets a [DocumentReference]{@link firestore.DocumentReference} instance that
 * refers to the document at the specified path.
 *
 * @public
 *
 * @param {string} documentPath - A slash-separated path to a document.
 * @return {firestore.DocumentReference} A reference to the specified
 * document.
 *
 * @example
 * var documentRef = firestore.doc('collection/document');
 * console.log(`Path of document is ${documentRef.path}`);
 */
Firestore.prototype.doc = function(documentPath) {
  validate.isString('documentPath', documentPath);

  var path = this.referencePath_.child(documentPath);
  if (!path.isDocument) {
    throw new Error('Argument "documentPath" must point to a document.');
  }

  return new DocumentReference(this, path);
};

/**
 * Gets a [CollectionReference]{@link firestore.CollectionReference} instance
 * that refers to the collection at the specified path.
 *
 * @public
 *
 * @param {string} collectionPath - A slash-separated path to a collection.
 * @return {firestore.CollectionReference} A reference to the specified
 * collection.
 *
 * @example
 * var collectionRef = firestore.collection('collection');
 *
 * // Add a document with an auto-generated ID.
 * collectionRef.add({foo: 'bar'}).then((documentRef) => {
 *   console.log(`Added document at ${documentRef.path})`);
 * });
 */
Firestore.prototype.collection = function(collectionPath) {
  validate.isString('collectionPath', collectionPath);

  var path = this.referencePath_.child(collectionPath);
  if (!path.isCollection) {
    throw new Error('Argument "collectionPath" must point to a collection.');
  }

  return new CollectionReference(this, path);
};

/**
 * Creates a [WriteBatch]{@link firestore.WriteBatch} instance that can be used
 * to atomically commit multiple writes.
 *
 * @public
 *
 * @return {firestore.WriteBatch} A WriteBatch that operates on this Firestore
 * client.
 *
 * @example
 * var writeBatch = firestore.batch();
 *
 * // Add two documents in an atomic batch.
 * var data = { foo: 'bar' };
 * writeBatch.set(firestore.doc('col/doc1'), data);
 * writeBatch.set(firestore.doc('col/doc2'), data);
 *
 * writeBatch.commit().then(res => {
 *   console.log(`Added document at ${res.writeResults[0].updateTime}`);
 * });
 */
Firestore.prototype.batch = function() {
  return new WriteBatch(this);
};

/**
 * Executes the given updateFunction and then attempts to commit the
 * changes applied within the transaction.
 *
 * You can use the transaction object passed to 'updateFunction' to read and
 * modify Firestore documents under lock. Transactions are committed once
 * 'updateFunction' resolves and attempted up to five times on failure.
 *
 * @public
 *
 * @param {function(firestore.Transaction)} updateFunction - The
 * function to execute within the transaction
 * context.
 * @param {object=} transactionOptions - Transaction options.
 * @param {number=} transactionOptions.maxAttempts - The maximum number of
 * attempts for this transaction.
 * @return {Promise} The promise returned from the updateFunction.
 *
 * @example
 * var counterTransaction = firestore.runTransaction(transaction => {
 *   var documentRef = firestore.doc('col/doc');
 *   return transaction.get(documentRef).then(doc => {
 *     if (doc.exists) {
 *       var count =  doc.get('count') || 0;
 *       if (count > 10) {
 *         return Promise.reject('Reached maximum count');
 *       }
 *       transaction.update(documentRef, { count: ++count });
 *       return Promise.resolve(count);
 *     }
 *
 *     transaction.create(documentRef, { count: 1 });
 *     return Promise.resolve(1);
 *   });
 * });
 *
 * counterTransaction.then(res => {
 *   console.log(`Count updated to ${res}`);
 * });
 */
Firestore.prototype.runTransaction = function(updateFunction,
                                              transactionOptions) {
  validate.isFunction('updateFunction', updateFunction);

  const defaultAttempts = 5;

  var attemptsRemaining = defaultAttempts;
  var previousTransaction;

  if (is.defined(transactionOptions)) {
    validate.isObject('transactionOptions', transactionOptions);
    validate.isOptionalInteger('transactionOptions.maxAttempts',
        transactionOptions.maxAttempts, 1);

    attemptsRemaining = transactionOptions.maxAttempts || attemptsRemaining;
    previousTransaction = transactionOptions.previousTransaction;
  }

  var transaction = new Transaction(this, previousTransaction);
  var result;

  --attemptsRemaining;

  return transaction.begin().then(() => {
    var promise = updateFunction(transaction);
    result = is.instanceof(promise, Promise) ? promise : Promise.reject(
      new Error('You must return a Promise in your transaction()-callback.'));

    return result.catch(() => {
      // Rollback the transaction and return the failed result.
      return transaction.rollback().then(() => { return result; });
    });
  }).then(() => {
    return transaction.commit().catch((err) => {
      if (attemptsRemaining > 0) {
        return this.runTransaction(updateFunction, {
          previousTransaction: transaction,
          maxAttempts: attemptsRemaining
        });
      }
      return Promise.reject(err);
    });
  }).then(() => {
    return result;
  });
};

/**
 * Retrieves multiple documents from Firestore.
 *
 * @public
 *
 * @param {
 * Array.<firestore.DocumentReference>|...firestore.DocumentReference} varArgs
 * The document references to receive.
 * @return {Promise<Array.<firestore.DocumentSnapshot>>} A Promise that
 * contains an array with the resulting document snapshots.
 *
 * @example
 * var documentRef1 = firestore.doc('col/doc1');
 * var documentRef2 = firestore.doc('col/doc2');
 *
 * firestore.getAll([documentRef1, documentRef2]).then(docs => {
 *   console.log(`First document: ${JSON.stringify(docs[0])}`);
 *   console.log(`Second document: ${JSON.stringify(docs[1])}`);
 * });
 */
Firestore.prototype.getAll = function(varArgs) {
  var documents = [];

  varArgs = is.array(arguments[0]) ? arguments[0] : [].slice.call(arguments);

  for (var i = 0; i < varArgs.length; ++i) {
    validate.isDocumentReference(i, varArgs[i]);
    documents.push(varArgs[i]);
  }

  return this.getAll_(documents, null);
};


/**
 * Internal method to retrieve multiple documents from Firestore, optionally as
 * part of a transaction.
 *
 * @package
 * @param {Array.<firestore.DocumentReference>} docRefs - The documents
 * to receive.
 * @param {object=} readOptions - The options to use for this request.
 * @param {bytes|null} readOptions.transactionId - The transaction ID to use for
 * this read.
 * @return {Array.<firestore.DocumentSnapshot|null>} A Promise that
 * contains an array with the resulting documents (or null for each missing
 * document).
 */
Firestore.prototype.getAll_ = function(docRefs, readOptions) {
  var request = {
    database: this.formattedName,
    documents: []
  };

  var inputOrder = {};

  // BatchGetDocuments doesn't preserve document order. We persist the
  // request order and restore it when we receive the result.
  for (var i = 0; i < docRefs.length; ++i) {
    inputOrder[docRefs[i].path] = i;
    request.documents.push(docRefs[i].formattedName);
  }

  if (readOptions && readOptions.transactionId) {
    request.transaction = readOptions.transactionId;
  }

  var self = this;
  var documents = [];

  return self.readStream(
    this.api.Firestore.batchGetDocuments.bind(this.api.Firestore),
    request
  ).then(stream => {
    return new Promise((resolve, reject) => {
      stream.on('error', (err) => {
        reject(err);
      }).on('data', response => {
        try {
          var document = DocumentSnapshot.Builder();

          if (response.found) {
            var found = response.found;
            document.ref = new DocumentReference(self,
                Path.fromName(found.name));
            document.fieldsProto = found.fields || {};
            document.createTime = DocumentSnapshot.toISOTime(found.createTime);
            document.updateTime = DocumentSnapshot.toISOTime(found.updateTime);
          } else {
            document.ref = new DocumentReference(self,
                Path.fromName(response.missing));
          }

          document.readTime = DocumentSnapshot.toISOTime(response.readTime);

          var path = document.ref.path;
          if (!is.defined(inputOrder[path])) {
            throw new Error(`Could not detect input order for "${path}".`);
          }

          documents[inputOrder[path]] = document.build();
        } catch (err) {
          reject(err);
        }
      }).on('end', () => {
        resolve(documents);
      });
    });
  });
};

/**
 * Generate a unique client-side identifier.
 *
 * Used for the creation of new documents.
 *
 * @package
 * @return {string} A unique 20-character wide identifier.
 */
Firestore.prototype.autoId = function() {
  var chars =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var autoId = '';
  for (var i = 0; i < 20; i++) {
    autoId += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return autoId;
};

/**
 * Decorate all request options before being sent with to an API request. This
 * is used to replace any `{{projectId}}` placeholders with the value detected
 * from the user's environment, if one wasn't provided manually.
 *
 * @private
 */
Firestore.prototype.decorateRequest_ = function(request) {
  var self = this;

  function decorate() {
    return new Promise((resolve) => {
      var decoratedRequest = extend(true, {}, request);
      decoratedRequest = common.util.replaceProjectIdToken(decoratedRequest,
        self.referencePath_.projectId_);

      var decoratedGax = {otherArgs: {headers: {}}};
      decoratedGax.otherArgs.headers[CLOUD_RESOURCE_HEADER] =
        self.formattedName;

      resolve({ request: decoratedRequest,  gax: decoratedGax });
    });
  }

  if (this.referencePath_.projectId_ !== '{{projectId}}') {
    return decorate();
  }

  return new Promise((resolve, reject) => {
    this.api.Firestore.getProjectId((err, projectId) => {
      if (err) {
        reject(err);
      } else {
        self.referencePath_ = new Path(
          projectId, self.referencePath_.databaseId_, []);
        decorate().then(resolve).catch(reject);
      }
    });
  });
};

/**
 * A funnel for all non-streaming API requests, assigning a project ID where
 * necessary within the request options.
 *
 * @package
 *
 * @param {function} method - Veneer API endpoint that takes a request and
 * GAX options.
 * @param {Object} request - The Protobuf request to send.
 * @return {Object} A Promise with the request result.
 */
Firestore.prototype.request = function(method, request) {
  return this.decorateRequest_(request).then(decorated => {
    return new Promise((resolve, reject) => {
      method(decorated.request, decorated.gax, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  });
};

/**
 * A funnel for read-only streaming API requests, assigning a project ID where
 * necessary within the request options.
 *
 * @package
 *
 * @param {function} method - Streaming Veneer API endpoint that takes a
 * request and GAX options.
 * @param {Object} request - The Protobuf request to send.
 * @return {Stream} A Promise with the resulting read-only stream.
 */
Firestore.prototype.readStream = function(method, request) {
  var self = this;

  return self.decorateRequest_(request).then((decorated) => {
    return method(decorated.request, decorated.gax);
  });
};

/**
 * A funnel for read-write streaming API requests, assigning a project ID where
 * necessary for all writes.
 *
 * @package
 *
 * @param {function} method - Streaming Veneer API endpoint that takes GAX
 * options.
 * @return {Stream} A Promise with the resulting read/write stream.
 */
Firestore.prototype.readWriteStream = function(method) {
  var self = this;

  return self.decorateRequest_({}).then((decorated) => {
    var requestStream = method(decorated.gax);

    var transform = through.obj(function(chunk, encoding, callback) {
      var decoratedChunk = extend(true, {}, chunk);
      common.util.replaceProjectIdToken(decoratedChunk,
        self.referencePath_.projectId_);
      this.push(decoratedChunk);
      callback();
    });

    return bun([transform, requestStream]);
  });
};

/**
 * Creates a [GeoPoint]{@link firestore.GeoPoint}.
 *
 * @param {number} latitude The latitude as a number between -90 and 90.
 * @param {number} longitude The longitude as a number between -180 and 180.
 * @return {firestore.GeoPoint} The GeoPoint pointing to the provided
 * location.
 *
 * @example
 * var data = {
 *   google: Firestore.geoPoint(37.422, 122.084)
 * };
 *
 * firestore.doc('col/doc').set(data).then(() => {
 *   console.log(`Location is ${data.google.latitude}, ` +
 *     `${data.google.longitude}`);
 * });
 */
Firestore.geoPoint = function(latitude, longitude) {
  validate.isNumber('latitude', latitude);
  validate.isNumber('longitude', longitude);

  return new GeoPoint(latitude, longitude);
};

/**
 * Creates an escaped field path from a list of field name components.
 *
 * @public
 *
 * @param {Array.<string>|...string} varArgs The unescaped components to encode
 * into the field path.
 * @return {string} A Firestore field path.
 *
 * @example
 * var documentRef = firestore.doc('col/doc');
 * var data = { outer: { inner1: 'foo', inner2: 'bar' }};
 * var fieldPath = Firestore.fieldPath('outer', 'inner1');
 *
 * documentRef.set(data).then(() => {
 *   return documentRef.get();
 * }).then((document) => {
 *   console.log(`Inner1 is defined: ${document.get(fieldPath)}`);
 *   return documentRef.update({ fieldPath: Firestore.FieldValue.delete() });
 * }).then(() => {
 *   return documentRef.get();
 * }).then((document) => {
 *   console.log(`Inner1 is undefined: ${document.get(fieldPath)}`);
 * });
 */
Firestore.fieldPath = function(varArgs) {
  varArgs = is.array(arguments[0]) ? arguments[0] : [].slice.call(arguments);

  for (var i = 0; i < varArgs.length; ++i) {
    validate.isString(i, varArgs[i]);
  }

  return DocumentSnapshot.encodeFieldPath(varArgs);
};

/**
 * @package
 */
Firestore.deleteSentinel = {};

/**
 * @package
 */
Firestore.serverTimestampSentinel = {};

/**
 * Sentinel values that can be used when writing documents with set() or
 * update().
 *
 * @public
 */
Firestore.FieldValue = {};

/**
 * Returns a sentinel used with update() to mark a field for deletion.
 *
 * @public
 *
 * @return {*} The sentinel value to use in your objects.
 *
 * @example
 * var documentRef = firestore.doc('col/doc');
 * var data = { a: 'b', c: 'd' };
 *
 * documentRef.set(data).then(() => {
 *   return documentRef.update({a: Firestore.FieldValue.delete()});
 * }).then(() => {
 *   // Document now only contains { c: 'd' }
 * });
 */
Firestore.FieldValue.delete = function() {
  return Firestore.deleteSentinel;
};

/**
 * Returns a sentinel used with set(), create() or update() to include a
 * server-generated timestamp in the written data.
 *
 * @public
 *
 * @return {*} The sentinel value to use in your objects.
 *
 * @example
 * var documentRef = firestore.doc('col/doc');
 *
 * documentRef.set({
 *   time: Firestore.FieldValue.serverTimestamp()
 * }).then(() => {
 *   return documentRef.get();
 * }).then(doc => {
 *   console.log(`Server time set to ${doc.get('time')}`);
 * });
 */
Firestore.FieldValue.serverTimestamp = function() {
  return Firestore.serverTimestampSentinel;
};

module.exports = Firestore;
module.exports.v1beta1 = v1beta1;
