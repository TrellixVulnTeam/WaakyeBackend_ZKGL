/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @module firestore/writebatch
 */

'use strict';

/**
 * Injected.
 *
 * @private
 * @type firestore.DocumentSnapshot
 */
var DocumentSnapshot;

/**
 * Injected.
 *
 * @private
 * @type firestore.DocumentMask
 */
var DocumentMask;

/**
 * Injected.
 *
 * @private
 * @type firestore.DocumentReference
 */
var DocumentReference;

/**
 * Injected.
 *
 * @private
 * @type firestore.DocumentTransform
 */
var DocumentTransform;

/**
 * Injected.
 *
 * @private
 * @type firestore.Precondition
 */
var Precondition;

/**
 * Injected.
 *
 * @private
 */
var validate;

/**
 * @class
 *
 * A Firestore WriteBatch that can be used to atomically commit multiple write
 * operations at once.
 *
 * @alias firestore.WriteBatch
 * @hideconstructor
 *
 * @param {firestore.Firestore} firestore - The Firestore Database client.
 */
function WriteBatch(firestore) {
  /**
   * The Firestore instance for the Firestore database (useful for performing
   * transactions, etc.).
   *
   * @public
   * @type firestore.Firestore
   * @name firestore.WriteBatch#firestore
   * @readonly
   *
   * @example
   * var writeBatch = firestore.batch();
   *
   * var client = writeBatch.firestore;
   * console.log(`Root location for document is ${client.formattedName}`);
   */
  Object.defineProperty(this, 'firestore', {
    value: firestore,
    writable: false
  });

  /**
   * @package
   */
  this.api = firestore.api;

  this.writes_ = [];
}

/**
 * Create a document with the provided object values. This will fail the batch
 * if a document exists at its location.
 *
 * @public
 * @param {firestore.DocumentReference} docRef The location of the
 *   document.
 * @param {Object} data - The object to serialize as the document.
 * @return {firestore.WriteBatch} The WriteBatch instance for chaining.
 *
 * @example
 * var writeBatch = firestore.batch();
 * var documentRef = firestore.collection('col').doc();
 *
 * writeBatch.create(documentRef, {foo: 'bar'});
 *
 * writeBatch.commit().then(() => {
 *   console.log('Successfully executed batch.');
 * });
 */
WriteBatch.prototype.create = function(docRef, data) {
  validate.isDocumentReference('docRef', docRef);
  validate.isDocument('data', data);

  var document = new DocumentSnapshot(docRef,
    DocumentSnapshot.encodeFields(data));
  var precondition = new Precondition({ exists: false });

  var write = {
    update: document.toProto(),
    currentDocument: precondition.toProto()
  };

  this.writes_.push(write);

  return this;
};

/**
 * Deletes a document from the database.
 *
 * @public
 * @param {firestore.DocumentReference} docRef The location of the
 *   document.
 * @param {object=} deleteOptions - The preconditions for this delete.
 * @param {string=} deleteOptions.lastUpdateTime If set, enforces that the
 * document was last updated at lastUpdateTime (as ISO 8601 string). Fails the
 * batch if the document doesn't exist or was last updated at a different time.
 * @return {firestore.WriteBatch} The WriteBatch instance for chaining.
 *
 * @example
 * var writeBatch = firestore.batch();
 * var documentRef = firestore.doc('col/doc');
 *
 * writeBatch.delete(documentRef);
 *
 * writeBatch.commit().then(() => {
 *   console.log('Successfully executed batch.');
 * });
 */
WriteBatch.prototype.delete = function(docRef, deleteOptions) {
  validate.isDocumentReference('docRef', docRef);
  validate.isOptionalPrecondition('deleteOptions', deleteOptions);

  var write = {
    delete: docRef.formattedName,
  };

  if (deleteOptions) {
    write.currentDocument = new Precondition({
      lastUpdateTime: deleteOptions.lastUpdateTime
    }).toProto();
  }

  this.writes_.push(write);

  return this;
};

/**
 * Write a document with the provided object values. By default, this will
 * create or overwrite existing documents.
 *
 * @public
 * @param {firestore.DocumentReference} docRef The location of the
 *   document.
 * @param {Object} data - The object to serialize as the document.
 * @param {object=} writeOptions - The preconditions for this set.
 * @param {boolean=} writeOptions.createIfMissing Whether the document should
 * be created if it doesn't yet exist. Defaults to true.
 * @param {string=} writeOptions.lastUpdateTime If set, enforces that the
 * document was last updated at lastUpdateTime (as ISO 8601 string). Fails the
 * batch if the document doesn't exist or was last updated at a different time.
 * @return {firestore.WriteBatch} The WriteBatch instance for chaining.
 *
 * @example
 * var writeBatch = firestore.batch();
 * var documentRef = firestore.doc('col/doc');
 *
 * writeBatch.set(documentRef, {foo: 'bar'});
 *
 * writeBatch.commit().then(() => {
 *   console.log('Successfully executed batch.');
 * });
 */
WriteBatch.prototype.set = function(docRef, data, writeOptions) {
  validate.isDocumentReference('docRef', docRef);
  validate.isDocument('data', data);
  validate.isOptionalPrecondition('writeOptions', writeOptions);

  var fields = DocumentSnapshot.encodeFields(data);

  var write = {
    update: new DocumentSnapshot(docRef, fields).toProto()
  };

  if (writeOptions) {
    var options = {};

    if (writeOptions.lastUpdateTime) {
      options.lastUpdateTime = writeOptions.lastUpdateTime;
    }

    if (writeOptions.createIfMissing === false) {
      options.exists = true;
    }

    write.currentDocument = new Precondition(options).toProto();
  }

  this.writes_.push(write);

  var documentTransform = DocumentTransform.fromObject(docRef, data);

  if (!documentTransform.isEmpty) {
    this.writes_.push({transform: documentTransform.toProto()});
  }

  return this;
};

/**
 * Update the fields of an existing document.
 *
 * Replaces the specified fields of an existing document with a new
 * collection of field values.
 *
 * @public
 * @param {firestore.DocumentReference} docRef The location of the
 *   document.
 * @param {object<string, *>} data A collection of fields to modify in a
 * document.
 * @param {object=} updateOptions - The preconditions for this update.
 * @param {boolean=} updateOptions.createIfMissing Whether the should be created
 * if it doesn't yet exist. Defaults to false.
 * @param {string=} updateOptions.lastUpdateTime If set, enforces that the
 * document was last updated at lastUpdateTime (as ISO 8601 string). Fails the
 * batch if the document doesn't exist or was last updated at a different time.
 * @return {firestore.WriteBatch} The WriteBatch instance for chaining.
 *
 * @example
 * var writeBatch = firestore.batch();
 * var documentRef = firestore.doc('col/doc');
 *
 * writeBatch.update(documentRef, {foo: 'bar'});
 *
 * writeBatch.commit().then(() => {
 *   console.log('Successfully executed batch.');
 * });
 */
WriteBatch.prototype.update = function(docRef, data, updateOptions) {
  validate.isDocumentReference('docRef', docRef);
  validate.isDocument('data', data, true);
  validate.isOptionalPrecondition('updateOptions', updateOptions);

  var documentMask = DocumentMask.fromObject(data);
  var expandedObject = DocumentSnapshot.expandObject(data);
  var document = new DocumentSnapshot(docRef,
    DocumentSnapshot.encodeFields(expandedObject));
  var precondition;

  if (updateOptions) {
    var options = {};

    if (updateOptions.lastUpdateTime) {
      options.lastUpdateTime =  updateOptions.lastUpdateTime;
    }

    if (updateOptions.createIfMissing !== true) {
      options.exists = true;
    }

    precondition = new Precondition(options);
  } else {
    precondition = new Precondition({exists: true});
  }

  var write = {
    update: document.toProto(),
    updateMask: documentMask.toProto(),
    currentDocument: precondition.toProto()
  };

  this.writes_.push(write);

  var documentTransform = DocumentTransform.fromObject(docRef, expandedObject);

  if (!documentTransform.isEmpty) {
    this.writes_.push({transform: documentTransform.toProto()});
  }

  return this;
};

/**
 * Verifies preconditions with the database and enforces constraints on the
 * batch.
 *
 * @private
 *
 * @todo Expose when server adds support.
 *
 * @param {firestore.DocumentReference} docRef The location of the
 *   document.
 * @param {object=} verifyOptions - The preconditions for this verification.
 * @param {boolean=} verifyOptions.exists Whether the document should exist.
 * @param {string=} verifyOptions.lastUpdateTime If set, verifies that the
 * document was last updated at lastUpdateTime (as ISO 8601 string). Fails the
 * batch if the document doesn't exist or was last updated at a different time.
 * @return {firestore.WriteBatch} The WriteBatch instance for chaining.
 */
WriteBatch.prototype.verify_ = function(docRef, verifyOptions) {
  validate.isDocumentReference('docRef', docRef);
  validate.isPrecondition('verifyOptions', verifyOptions);

  var write = {
    verify: docRef.formattedName,
    currentDocument: new Precondition({
      exists: verifyOptions.exists,
      lastUpdateTime: verifyOptions.lastUpdateTime
    }).toProto()
  };

  this.writes_.push(write);

  return this;
};

/**
 * Atomically commits all pending operations to the database and verifies all
 * preconditions. Fails the entire batch if any precondition is not met.
 *
 * @public
 * @param {object=} commitOptions Options to use for this commit.
 * @param {bytes=} commitOptions.transactionId The transaction ID of this
 * commit.
 * @return {Promise.<Array.<firestore.WriteResult>>} A Promise that resolves
 * when this batch completes.
 *
 * @example
 * var writeBatch = firestore.batch();
 * var documentRef = firestore.doc('col/doc');
 *
 * writeBatch.set(documentRef, {foo: 'bar'});
 *
 * writeBatch.commit().then(() => {
 *   console.log('Successfully executed batch.');
 * });
 */
WriteBatch.prototype.commit = function(commitOptions) {
  var request = {
    database: this.firestore.formattedName,
    writes: this.writes_
  };

  if (commitOptions && commitOptions.transactionId) {
    request.transaction = commitOptions.transactionId;
  }

  var self = this;

  return self.firestore.request(
    self.api.Firestore.commit.bind(self.api.Firestore), request
  ).then(resp => {
    var commitTime = DocumentSnapshot.toISOTime(resp.commitTime);
    var result = {
      writeResults: []
    };

    for (var writeResult of resp.writeResults) {
      result.writeResults.push(new WriteResult(
          DocumentSnapshot.toISOTime(writeResult.updateTime) || commitTime));
    }

    return result;
  });
};

/**
 * Checks if this write batch has any pending operations.
 *
 * @return {boolean}
 * @package
 */
WriteBatch.prototype.isEmpty_ = function() {
  return this.writes_.length === 0;
};


/**
 * @class
 *
 * A WriteResult wraps the write time set by the Firestore servers on sets(),
 * updates(), and creates().
 *
 * @alias firestore.WriteResult
 * @hideconstructor
 *
 * @param {string} writeTime - The ISO 8601 write time.
 */
function WriteResult(writeTime) {
  /**
   * The write time as set by the Firestore servers. Formatted as an ISO-8601
   * string.
   *
   * @public
   * @type string
   * @name firestore.WriteResult#writeTime
   * @readonly
   *
   * @example
   * var documentRef = firestore.doc('col/doc');
   *
   * documentRef.set({foo: 'bar'}).then(writeResult => {
   *   console.log(`Document written at: ${writeResult.writeTime}`);
   * });
   */
  Object.defineProperty(this, 'writeTime', {
    value: writeTime,
    writable: false
  });
}

module.exports = (FirestoreType, DocumentRefType,
    validateDocumentReference) => {
      var document = require('./document.js')(FirestoreType, DocumentRefType);
      DocumentReference = DocumentRefType;
      DocumentMask = document.DocumentMask;
      DocumentSnapshot = document.DocumentSnapshot;
      DocumentTransform = document.DocumentTransform;
      Precondition = document.Precondition;
      validate = require('./validate')({
    Document: document.validateDocumentData,
    DocumentReference: validateDocumentReference,
    Precondition: document.validatePrecondition
  });
  return { WriteBatch: WriteBatch, WriteResult: WriteResult };
};
