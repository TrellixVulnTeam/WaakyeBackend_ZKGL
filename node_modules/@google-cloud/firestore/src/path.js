/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @module firestore/path
 */

'use strict';

/**
 * An immutable representation of a Firestore path to a Document or Collection.
 *
 * @constructor
 * @alias firestore.Path
 * @package
 *
 * @param {string} projectId - The Firestore project id.
 * @param {string} databaseId - The Firestore database id.
 * @param {Array.<string>} pathComponents - Sequence of names of the parts of
 * a path.
 */
function Path(projectId, databaseId, pathComponents) {
  this.projectId_ = projectId;
  this.databaseId_ = databaseId;
  this.parts_ = pathComponents;

  /**
   * @package
   * @type boolean
   */
  this.isDocument = this.parts_.length > 0 && this.parts_.length % 2 === 0;

  /**
   * @package
   * @type boolean
   */
  this.isCollection = this.parts_.length % 2 === 1;

  /**
   * The Path's last document id.
   *
   * @package
   * @type string|null
   */
  Object.defineProperty(this, 'documentId', {
    get: () => {
      if (this.isDocument) {
        return this.parts_[this.parts_.length - 1];
      }
      return null;
    },
  });

  /**
   * String representation as expected by the API.
   *
   * @package
   * @type string
   */
  Object.defineProperty(this, 'formattedName', {
    get: () => {
      var components = ['projects', this.projectId_, 'databases',
        this.databaseId_];
      if (this.parts_.length > 0) {
        components = components.concat('documents', this.parts_);
      }
      return components.join('/');
    },
  });

  /**
   * String representation of the path relative to the database root.
   *
   * @package
   * @type string
   */
  Object.defineProperty(this, 'relativeName', {
    get: () => {
      return this.parts_.join('/');
    },
  });

  /**
   * The Path's last collection id.
   *
   * @package
   * @type string|null
   */
  Object.defineProperty(this, 'collectionId', {
    get: () => {
      if (this.isCollection) {
        return this.parts_[this.parts_.length - 1];
      }
      if (this.isDocument) {
        return this.parts_[this.parts_.length - 2];
      }
      return null;
    },
  });
}

/**
 * Create a child path beneath the current level.
 *
 * @package
 * @param {string} relativePath - Slash-separated path to append to the current
 * path.
 * @return {Path} The new path.
 */
Path.prototype.child = function(relativePath) {
  return new Path(this.projectId_, this.databaseId_,
      this.parts_.concat(relativePath.split('/')));
};

/**
 * Returns the path of the parent node.
 *
 * @package
 * @return {Path|null} The new path or null if we are already at the root.
 */
Path.prototype.parent = function() {
  if (this.parts_.length === 0) {
    return null;
  }

  return new Path(this.projectId_, this.databaseId_,
      this.parts_.slice(0, this.parts_.length - 1));
};

/**
 * Returns the Path from its string representation.
 *
 * @package
 * @param {string} name The Firestore resource name of this path.
 * @return {Path} The Path for this resource name.
 */
Path.fromName = function(name) {
  var parts = name.split('/');

  if (parts.length >= 6 &&
      parts[0] === 'projects' &&
      parts[2] === 'databases' &&
      parts[4] === 'documents') {
    return new Path(parts[1], parts[3], parts.slice(5));
  }

  if (parts.length >= 4 &&
    parts[0] === 'projects' &&
    parts[2] === 'databases') {
    return new Path(parts[1], parts[3], []);
  }

  throw new Error('Provided resource name is not valid.');
};

/**
 * Compares two paths.
 *
 * @package
 * @return {number} - -1 if left < right, 1 if right > left, 0 if equal
 */
Path.compare = function(left, right) {
  if (left.projectId_ < right.projectId_) {
    return -1;
  }
  if (left.projectId_ > right.projectId_) {
    return 1;
  }

  if (left.databaseId_ < right.databaseId_) {
    return -1;
  }
  if (left.databaseId_ > right.databaseId_) {
    return 1;
  }

  const len = Math.min(left.parts_.length, right.parts_.length);
  for (let i = 0; i < len; i++) {
    if (left.parts_[i] < right.parts_[i]) {
      return -1;
    }
    if (left.parts_[i] > right.parts_[i]) {
      return 1;
    }
  }
  if (left.parts_.length < right.parts_.length) {
    return -1;
  }
  if (left.parts_.length > right.parts_.length) {
    return 1;
  }
  return 0;
};

module.exports = Path;
